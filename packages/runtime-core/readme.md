diff dom 树解析不会是递归操作，递归的性能很差

1. key 做标识的 提升 diff 算法性能
   [a,b,c,d]=>[f,a,b,c,d], 不加 key 在数组前面插入 f 的时候，所有的 dom 点会重新更新，加入 key 之后，只做将 f 插入前面
2. 只做同级比较，不会跨层级比较
   [{ul>li*3}] => [{div>li*3}] 子元素将全部更新，不会在关心 likey 是否相等
3. diff 算法是拿 h 虚拟 dom 树结构（计算或者比较）然后通过 patch 更新 dom（更新视图）

4. 首先比较新旧节点是不是同一个节点（type 和 key 是否相同）不是同一个节点进行暴力删除（先以旧节点位基准插入新节点，然后在删除旧节点）
   如果是同一个节点则需要进一步比较
   1.1 完全相同，不做处理
   1.2 新节点内容位文本，直接替换
   1.3 新节点有子节点
   1.3.1 老节点为文本，清空文本，将新节点子元素插入
   1.3.2 老节点有子元素，继续比较
